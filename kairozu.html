<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lチカ実習：回路設計シミュレーター</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; color: #333; max-width: 900px; margin: 0 auto; }
    h2 { margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    .desc { font-size: 14px; color: #444; margin-bottom: 15px; line-height: 1.5; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    
    button { padding: 6px 14px; cursor: pointer; background: #0969da; color:white; border:none; border-radius:4px; font-size: 13px; }
    button:hover { background: #0250bb; }
    button#clearBtn { background: #d1242f; }
    button.secondary { background: #6e7781; }
    button.secondary:hover { background: #57606a; }
    
    #stage { border:1px solid #ccc; border-radius:8px; width:100%; height:420px; background: #fafafa; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    
    #status { 
      padding: 8px 12px; margin-bottom: 10px;
      background:#f3f3f3; border-left: 4px solid #888; border-radius:2px; 
      font-size: 14px; color: #333;
    }
    #status.error { background: #fff0f0; border-left-color: #d1242f; color: #b31d28; }
    #status.warning { background: #fffbe6; border-left-color: #d4b106; color: #5c4d00; }
    #status.success { background: #f0fff4; border-left-color: #1a7f37; color: #116329; }

    /* SVG Elements */
    .pin { cursor:pointer; transition: r 0.1s; }
    .pin:hover { r: 10; }
    .pin.selected { stroke:#0969da; stroke-width:3; fill: #e6f2ff; }
    
    .part-label { font-size:13px; user-select:none; font-weight: bold; fill: #444; pointer-events: none; }
    .pin-label { font-size:11px; user-select:none; fill: #666; pointer-events: none; }

    /* Wiring */
    .edge { cursor:pointer; stroke-linecap: round; }
    .edge.wire { stroke:#333; stroke-width:3; }
    .edge.res  { stroke:#333; stroke-width:3; stroke-dasharray:6 4; }
    .edge.hit { stroke: transparent; stroke-width: 16; }
    
    .val-label { font-size: 12px; font-family: monospace; fill: #d1242f; font-weight: bold; paint-order: stroke; stroke: rgba(255,255,255,0.9); stroke-width: 3px; pointer-events: none; }

    /* LED Styles */
    .led-body { stroke:#444; stroke-width:1.5; }
    .led-on  { fill: #ffdd66; filter: drop-shadow(0 0 6px #ffdd66); } 
    .led-off { fill: #eee; }
    .led-burnt { fill: #333; }

    /* JSON Area */
    details { margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px; }
    summary { font-size: 13px; color: #0969da; cursor: pointer; font-weight: bold; }
    textarea { width: 100%; height: 80px; font-family: monospace; font-size: 12px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
  </style>
</head>
<body>

  <h2>実習：Lチカ回路の設計</h2>
  
  <div class="desc">
    <strong>条件:</strong> ESP32電源電圧=3.3V, 赤色LED順方向電圧(<i>V</i><sub>F</sub>)=2.0V<br>
    LEDを点滅させるため、適切なピンと抵抗を選んで配線してください。<br>
    <small>※端子記号: <strong>A</strong>=アノード(プラス極), <strong>K</strong>=カソード(マイナス極)</small>
    <ul style="margin: 5px 0 0 20px; padding:0;">
        <li>端子間をクリックして接続。線をクリックして抵抗値を変更 (WIRE ↔ 抵抗)。</li>
    </ul>
  </div>

  <div class="row">
    <button id="runBtn">▶ 電源ON</button>
    <button id="clearBtn" class="secondary" style="margin-left:auto;">全消去</button>
  </div>
  
  <div id="status">準備完了: 回路を作成してください</div>

  <svg id="stage" viewBox="0 0 800 420"></svg>

  <details>
    <summary>回路データの保存/読み込み (JSON)</summary>
    <div style="margin-top: 5px;">
        <button id="exportBtn" class="secondary">現在の回路を保存 (Export)</button>
        <button id="importBtn" class="secondary">データを読み込み (Import)</button>
    </div>
    <textarea id="jsonBox" placeholder="ここにJSONデータが表示されます。読み込む場合はここに貼り付けてボタンを押してください。"></textarea>
  </details>

<script>
// --- 設定 & 定数 ---
const RES_VALUES = [0, 10, 100, 1000, 10000];
const RES_LABELS = { 0:"WIRE", 10:"10Ω", 100:"100Ω", 1000:"1kΩ", 10000:"10kΩ" };

// 部品定義 (LEDを縦長に変更)
const parts = [
  {
    id: "esp32", name: "ESP32", x: 60, y: 80, w: 140, h: 260,
    pins: [
      { name: "3V3",   dx: 140, dy: 60 },
      { name: "GPIO2", dx: 140, dy: 130 },
      { name: "GND",   dx: 140, dy: 200 },
    ]
  },
  {
    id: "led", name: "LED", x: 400, y: 130, w: 80, h: 140,
    pins: [
      { name: "A", dx: 40, dy: 20 }, // Top
      { name: "K", dx: 40, dy: 120 }, // Bottom
    ]
  }
];

// --- 状態管理 ---
let connections = []; // { id, from, to, ohms }
let selectedPinId = null;
let isRunning = false;
let blinkInterval = null;
let ledState = "off"; 

// --- DOM取得 ---
const svg = document.getElementById("stage");
const statusEl = document.getElementById("status");
const runBtn = document.getElementById("runBtn");
const jsonBox = document.getElementById("jsonBox");

// --- イベントリスナー ---
document.getElementById("clearBtn").addEventListener("click", () => {
  resetSim();
  connections = [];
  selectedPinId = null;
  setStatus("回路を全消去しました", "");
  render();
});

document.getElementById("exportBtn").addEventListener("click", () => {
  const data = { connections: connections };
  jsonBox.value = JSON.stringify(data);
  setStatus("回路データをJSONとして出力しました", "");
});

document.getElementById("importBtn").addEventListener("click", () => {
  try {
    const val = jsonBox.value.trim();
    if(!val) return;
    const data = JSON.parse(val);
    if(Array.isArray(data.connections)) {
        resetSim();
        connections = data.connections;
        selectedPinId = null;
        setStatus("回路データを読み込みました", "success");
        render();
    } else {
        throw new Error("Invalid Format");
    }
  } catch(e) {
    setStatus("読み込みエラー: JSON形式が正しくありません", "error");
  }
});

runBtn.addEventListener("click", () => {
  if (isRunning) {
    resetSim();
    return;
  }
  
  const result = analyzeCircuit();
  
  if (!result.connected) {
    setStatus("回路が不完全です (電源からGNDまで通電していません)", "error");
    return;
  }

  // 短絡チェック
  if (result.totalResistance <= 0) {
    startBurnout();
    setStatus("短絡(ショート)しています。抵抗を入れてください", "error");
    return;
  }

  // 電流計算 (3.3V電源, Vf=2.0V)
  const V_source = 3.3;
  const V_f = 2.0;
  const I_ma = ((V_source - V_f) / result.totalResistance) * 1000;

  startBlink(I_ma, result.sourcePin);
});

// --- シミュレーション制御 ---
function resetSim() {
  isRunning = false;
  ledState = "off";
  if (blinkInterval) clearInterval(blinkInterval);
  runBtn.textContent = "▶ 電源ON";
  setStatus("停止中", "");
  render();
}

function setStatus(msg, type) {
  statusEl.textContent = msg;
  statusEl.className = type; 
}

function startBurnout() {
  isRunning = true;
  ledState = "burnt";
  runBtn.textContent = "■ リセット";
  render();
}

function startBlink(current_ma, sourcePin) {
  isRunning = true;
  runBtn.textContent = "■ 電源OFF";
  
  let msg = `電流値: ${current_ma.toFixed(1)} mA`;
  let type = "";
  let allowBlink = true;

  // 1. ピン判定
  if (sourcePin === "3V3") {
    msg += " (警告: 3V3接続のため制御不可。GPIOを使用してください)";
    type = "warning";
    allowBlink = false;
    ledState = "on"; 
  }
  
  // 2. 電流判定
  if (current_ma > 25) {
    msg += " [過大] 素子が破損しました (抵抗値不足)";
    ledState = "burnt";
    type = "error";
    setStatus(msg, type);
    render();
    return;
  } else if (current_ma < 2.0) {
    msg += " [不足] 点灯しません (抵抗値過大)";
    type = "error";
    ledState = "off";
    if(type !== "error") setStatus(msg, type); 
  } else {
    if (sourcePin === "GPIO") {
        msg += " [適正] 正常動作中";
        type = "success";
    }
  }

  setStatus(msg, type);

  if (allowBlink && current_ma >= 2.0) {
      let on = false;
      blinkInterval = setInterval(() => {
        on = !on;
        ledState = on ? "on" : "off";
        render();
      }, 500);
  } else {
      render();
  }
}

// --- 回路解析 ---
function analyzeCircuit() {
  const P_3V3  = "esp32:3V3";
  const P_GPIO = "esp32:GPIO2";
  const P_GND  = "esp32:GND";
  const P_A    = "led:A";
  const P_K    = "led:K";

  // 隣接リスト作成
  const adj = {};
  const getAdj = (id) => { if(!adj[id]) adj[id]=[]; return adj[id]; };
  connections.forEach(c => {
    getAdj(c.from).push({ to: c.to, r: c.ohms });
    getAdj(c.to).push({ to: c.from, r: c.ohms });
  });

  const findPath = (start, end) => {
    const q = [{ curr: start, r: 0, path: [start] }];
    const visited = new Set(); // ループ回避
    while(q.length > 0) {
      const { curr, r, path } = q.shift();
      if (curr === end) return { found: true, r };
      
      visited.add(curr);
      for(const n of (adj[curr]||[])) {
        if(!visited.has(n.to)) {
          q.push({ curr: n.to, r: r + n.r, path: [...path, n.to] });
        }
      }
    }
    return { found: false, r: 0 };
  };

  // GNDへのパス確認
  const gndPath = findPath(P_K, P_GND);
  if (!gndPath.found) return { connected: false };

  // 電源(GPIO or 3V3)からのパス確認
  const gpioPath = findPath(P_GPIO, P_A);
  if (gpioPath.found) {
    return { connected: true, sourcePin: "GPIO", totalResistance: gpioPath.r + gndPath.r };
  }
  
  const v33Path = findPath(P_3V3, P_A);
  if (v33Path.found) {
    return { connected: true, sourcePin: "3V3", totalResistance: v33Path.r + gndPath.r };
  }

  return { connected: false };
}

// --- 描画処理 ---
function pinId(partId, pinName) { return `${partId}:${pinName}`; }
function parsePinId(id) { const [pid, pname] = id.split(":"); return { pid, pname }; }
function getPinPos(id) {
  const { pid, pname } = parsePinId(id);
  const part = parts.find(p => p.id === pid);
  const pin = part.pins.find(p => p.name === pname);
  return { x: part.x + pin.dx, y: part.y + pin.dy };
}
function cryptoId() { return Math.random().toString(36).slice(2); }

function onPinClick(e) {
  if (isRunning) return; 
  const id = e.currentTarget.getAttribute("data-id");
  if (!selectedPinId) { selectedPinId = id; render(); return; }
  if (selectedPinId === id) { selectedPinId = null; render(); return; }

  const exists = connections.some(c => 
    (c.from === selectedPinId && c.to === id) || (c.from === id && c.to === selectedPinId)
  );
  if (!exists) connections.push({ id: cryptoId(), from: selectedPinId, to: id, ohms: 0 });
  selectedPinId = null;
  render();
}

function onEdgeClick(e) {
  if (isRunning) return;
  const id = e.currentTarget.getAttribute("data-id");
  const idx = connections.findIndex(c => c.id === id);
  if (idx < 0) return;

  if (e.shiftKey) {
    connections.splice(idx, 1);
  } else {
    const currentR = connections[idx].ohms;
    const i = RES_VALUES.indexOf(currentR);
    connections[idx].ohms = RES_VALUES[(i + 1) % RES_VALUES.length];
  }
  render();
}

function render() {
  svg.innerHTML = "";

  // 1. 部品描画
  parts.forEach(p => {
    // 本体
    svg.appendChild(el("rect", { 
      x:p.x, y:p.y, width:p.w, height:p.h, rx:4, fill:"#fff", stroke:"#888", "stroke-width":2 
    }));
    const label = el("text", { x:p.x+8, y:p.y+20, class:"part-label" });
    label.textContent = p.name;
    svg.appendChild(label);

    // LED描画 (中央配置)
    if (p.id === "led") {
        const cx = p.x + p.w/2;
        const cy = p.y + p.h/2; 
        let fillClass = "led-off";
        if (ledState === "on") fillClass = "led-on";
        if (ledState === "burnt") fillClass = "led-burnt";
        svg.appendChild(el("circle", { cx, cy, r:25, class:`led-body ${fillClass}` }));
    }
  });

  // 2. 配線描画
  connections.forEach(c => {
    const p1 = getPinPos(c.from);
    const p2 = getPinPos(c.to);
    const isWire = (c.ohms === 0);
    
    const line = el("line", { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y, class: isWire ? "edge wire" : "edge res" });
    svg.appendChild(line);
    
    const hit = el("line", { x1:p1.x, y1:p1.y, x2:p2.x, y2:p2.y, class:"edge hit", "data-id":c.id });
    hit.addEventListener("click", onEdgeClick);
    svg.appendChild(hit);

    if (!isWire) {
      const mx = (p1.x + p2.x)/2;
      const my = (p1.y + p2.y)/2 - 8; 
      const txt = el("text", { x:mx, y:my, class:"val-label", "text-anchor":"middle" });
      txt.textContent = RES_LABELS[c.ohms];
      svg.appendChild(txt);
    }
  });

  // 3. ピン描画
  parts.forEach(p => {
    p.pins.forEach(pin => {
      const pid = pinId(p.id, pin.name);
      const pos = getPinPos(pid);
      const isSel = (selectedPinId === pid);
      
      const pinG = el("g", {});
      const circle = el("circle", { 
        cx:pos.x, cy:pos.y, r:6, 
        class: "pin" + (isSel ? " selected" : ""),
        fill: "#fff", stroke: "#333", "stroke-width":2,
        "data-id": pid 
      });
      circle.addEventListener("click", onPinClick);
      pinG.appendChild(circle);
      
      // ピンラベル制御: 配線がつながっていたら非表示にする
      const isConnected = connections.some(c => c.from === pid || c.to === pid);
      
      if (!isConnected) {
          let tx = pos.x + 10;
          let ty = pos.y + 4;
          let anchor = "start";
          
          if (p.id === "esp32") {
              tx = pos.x - 12;
              anchor = "end";
          } else if (p.id === "led") {
              // 縦配置なので横にラベルを出す
              tx = pos.x + 12;
              anchor = "start";
          }

          const txt = el("text", { x:tx, y:ty, class:"pin-label", "text-anchor":anchor });
          txt.textContent = pin.name;
          pinG.appendChild(txt);
      }
      
      svg.appendChild(pinG);
    });
  });
}

function el(tag, attrs) {
  const n = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for(const k in attrs) n.setAttribute(k, attrs[k]);
  return n;
}

render();
</script>
</body>
</html>